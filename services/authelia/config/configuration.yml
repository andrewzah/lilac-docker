host: 0.0.0.0
port: 9091
theme: light

server:
  read_buffer_size: 4096
  write_buffer_size: 4096
  path: ""

log_level: debug
log_file_path: /config/authelia.log

# The secret used to generate JWT tokens when validating user identity by
# email confirmation.
# JWT Secret can also be set using a secret: https://docs.authelia.com/configuration/secrets.html
jwt_secret: "0c69ece95dc9d1f1df27ec5b7fb2fca2f05155c7a85fa9883c24d12affaeb44e531ec4d9ea164e873c7b10aeea4cb3082685f85450604fc249ee248db2ea2777" 

# Default redirection URL
#
# If user tries to authenticate without any referer, Authelia
# does not know where to redirect the user to at the end of the
# authentication process.
# This parameter allows you to specify the default redirection
# URL Authelia will use in such a case.
#
# Note: this parameter is optional. If not provided, user won't
# be redirected upon successful authentication.
#default_redirection_url: https://home.example.com:8080/

totp:
  issuer: login.zah.rocks
  period: 30
  skew: 1

#duo_api:
#  hostname: api-123456789.example.com
#  integration_key: ABCDEF
#  # Secret can also be set using a secret: https://docs.authelia.com/configuration/secrets.html
#  secret_key: 1234567890abcdefghifjkl

authentication_backend:
  disable_reset_password: false

  refresh_interval: 5m

  #ldap:
  #  implementation: custom

  #  # The url to the ldap server. Scheme can be ldap or ldaps in the format (port optional) <scheme>://<address>[:<port>].
  #  #url: ldap://127.0.0.1
  #  
  #  # Use StartTLS with the LDAP connection.
  #  start_tls: false

  #  tls:
  #    # Server Name for certificate validation (in case it's not set correctly in the URL).
  #    # server_name: ldap.example.com

  #    # Skip verifying the server certificate (to allow a self-signed certificate).
  #    skip_verify: false

  #    # Minimum TLS version for either Secure LDAP or LDAP StartTLS.
  #    minimum_version: TLS1.2

  #  # The base dn for every entries.
  #  base_dn: dc=example,dc=com
  #  
  #  # The attribute holding the username of the user. This attribute is used to populate
  #  # the username in the session information. It was introduced due to #561 to handle case
  #  # insensitive search queries.
  #  # For you information, Microsoft Active Directory usually uses 'sAMAccountName' and OpenLDAP
  #  # usually uses 'uid'
  #  # Beware that this attribute holds the unique identifiers for the users binding the user and the configuration
  #  # stored in database. Therefore only single value attributes are allowed and the value
  #  # must never be changed once attributed to a user otherwise it would break the configuration
  #  # for that user. Technically, non-unique attributes like 'mail' can also be used but we don't recommend using
  #  # them, we instead advise to use the attributes mentioned above (sAMAccountName and uid) to follow
  #  # https://www.ietf.org/rfc/rfc2307.txt.
  #  # username_attribute: uid
  #  
  #  # An additional dn to define the scope to all users.
  #  additional_users_dn: ou=users

  #  # The users filter used in search queries to find the user profile based on input filled in login form.
  #  # Various placeholders are available to represent the user input and back reference other options of the configuration:
  #  # - {input} is a placeholder replaced by what the user inputs in the login form. 
  #  # - {username_attribute} is a mandatory placeholder replaced by what is configured in `username_attribute`.
  #  # - {mail_attribute} is a placeholder replaced by what is configured in `mail_attribute`.
  #  # - DON'T USE - {0} is an alias for {input} supported for backward compatibility but it will be deprecated in later versions, so please don't use it.
  #  #
  #  # Recommended settings are as follows:
  #  # - Microsoft Active Directory: (&({username_attribute}={input})(objectCategory=person)(objectClass=user))
  #  # - OpenLDAP: (&({username_attribute}={input})(objectClass=person))' or '(&({username_attribute}={input})(objectClass=inetOrgPerson))
  #  #
  #  # To allow sign in both with username and email, one can use a filter like
  #  # (&(|({username_attribute}={input})({mail_attribute}={input}))(objectClass=person))
  #  users_filter: (&({username_attribute}={input})(objectClass=person))

  #  # An additional dn to define the scope of groups.
  #  additional_groups_dn: ou=groups
  #  
  #  # The groups filter used in search queries to find the groups of the user.
  #  # - {input} is a placeholder replaced by what the user inputs in the login form.
  #  # - {username} is a placeholder replace by the username stored in LDAP (based on `username_attribute`).
  #  # - {dn} is a matcher replaced by the user distinguished name, aka, user DN.
  #  # - {username_attribute} is a placeholder replaced by what is configured in `username_attribute`.
  #  # - {mail_attribute} is a placeholder replaced by what is configured in `mail_attribute`.
  #  # - DON'T USE - {0} is an alias for {input} supported for backward compatibility but it will be deprecated in later versions, so please don't use it.
  #  # - DON'T USE - {1} is an alias for {username} supported for backward compatibility but it will be deprecated in later version, so please don't use it.
  #  # If your groups use the `groupOfUniqueNames` structure use this instead: (&(uniquemember={dn})(objectclass=groupOfUniqueNames))
  #  groups_filter: (&(member={dn})(objectclass=groupOfNames))

  #  # The attribute holding the name of the group
  #  # group_name_attribute: cn

  #  # The attribute holding the mail address of the user. If multiple email addresses are defined for a user, only the first
  #  # one returned by the LDAP server is used.
  #  # mail_attribute: mail

  #  # The attribute holding the display name of the user. This will be used to greet an authenticated user.
  #  # display_name_attribute: displayname

  #  # The username and password of the admin user.
  #  user: cn=admin,dc=example,dc=com
  #  # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html
  #  password: password

  # File backend configuration.
  #
  # With this backend, the users database is stored in a file
  # which is updated when users reset their passwords.
  # Therefore, this backend is meant to be used in a dev environment
  # and not in production since it prevents Authelia to be scaled to
  # more than one instance. The options under 'password' have sane
  # defaults, and as it has security implications it is highly recommended
  # you leave the default values. Before considering changing these settings
  # please read the docs page below:
  # https://docs.authelia.com/configuration/authentication/file.html#password-hash-algorithm-tuning
  #
  file:
    path: /config/users_database.yml
    password:
      algorithm: argon2id
      iterations: 1
      key_length: 32
      salt_length: 16
      parallelism: 8
      memory: 1024
# Access Control
#
# Access control is a list of rules defining the authorizations applied for one
# resource to users or group of users.
#
# If 'access_control' is not defined, ACL rules are disabled and the 'bypass'
# rule is applied, i.e., access is allowed to anyone. Otherwise restrictions follow
# the rules defined.
#
# Note: One can use the wildcard * to match any subdomain.
# It must stand at the beginning of the pattern. (example: *.mydomain.com)
#
# Note: You must put patterns containing wildcards between simple quotes for the YAML
# to be syntactically correct.
#
# Definition: A 'rule' is an object with the following keys: 'domain', 'subject',
# 'policy' and 'resources'.
#
# - 'domain' defines which domain or set of domains the rule applies to.
#
# - 'subject' defines the subject to apply authorizations to. This parameter is
#    optional and matching any user if not provided. If provided, the parameter
#    represents either a user or a group. It should be of the form 'user:<username>'
#    or 'group:<groupname>'.
#
# - 'policy' is the policy to apply to resources. It must be either 'bypass',
#   'one_factor', 'two_factor' or 'deny'.
#
# - 'resources' is a list of regular expressions that matches a set of resources to
#    apply the policy to. This parameter is optional and matches any resource if not
#    provided.
#
# Note: the order of the rules is important. The first policy matching
# (domain, resource, subject) applies.
access_control:
  # Default policy can either be 'bypass', 'one_factor', 'two_factor' or 'deny'.
  # It is the policy applied to any resource if there is no policy to be applied
  # to the user.
  default_policy: deny

  networks:
    - name: internal
      networks:
        - 10.10.0.0/16
        - 192.168.2.0/24
    - name: VPN
      networks: 10.9.0.0/16

  rules:
    # Rules applied to everyone
    #- domain: public.example.com
    #  policy: bypass
    
    - domain: "*.zah.rocks"
      policy: one_factor
    
    - domain: "*.zah.rocks"
      subject:
        - "group:admins"
        - "group:moderators"
      policy: two_factor

    #- domain: secure.example.com
    #  policy: one_factor
    #  # Network based rule, if not provided any network matches.
    #  networks:
    #    - internal
    #    - VPN
    #    - 192.168.1.0/24
    #    - 10.0.0.1
    #
    #- domain:
    #  - secure.example.com
    #  - private.example.com
    #  policy: two_factor
    #    - domain: singlefactor.example.com
    #      policy: one_factor
    #
    # Rules applied to 'admins' group
    #    - domain: "mx2.mail.example.com"
    #      subject: "group:admins"
    #      policy: deny
    #
    #
    # Rules applied to 'dev' group
    #    - domain: dev.example.com
    #      resources:
    #        - "^/groups/dev/.*$"
    #      subject: "group:dev"
    #      policy: two_factor
    #
    # Rules applied to user 'john'
    #- domain: dev.example.com
    #  resources:
    #    - "^/users/john/.*$"
    #  subject: "user:john"
    #  policy: two_factor

    # Rules applied to user 'harry'
    #- domain: dev.example.com
    #  resources:
    #    - "^/users/harry/.*$"
    #  subject: "user:harry"
    #  policy: two_factor

    # Rules applied to user 'bob'
    #- domain: "*.mail.example.com"
    #  subject: "user:bob"
    #  policy: two_factor
    #- domain: "dev.example.com"
    #  resources:
    #    - "^/users/bob/.*$"
    #  subject: "user:bob"
    #  policy: two_factor

# Configuration of session cookies
#
# The session cookies identify the user once logged in.
session:
  # The name of the session cookie. (default: authelia_session).
  name: authelia_session

  # The secret to encrypt the session data. This is only used with Redis.
  # Secret can also be set using a secret: https://docs.authelia.com/configuration/secrets.html
  secret: AUTHELIA_SESSION_SECRET_FILE

  expiration: 1h
  inactivity: 5m
  remember_me_duration: 1M
  domain: zah.rocks

  # The redis connection details
  redis:
    host: redis
    port: 6379
    # Use a unix socket instead
    # host: /var/run/redis/redis.sock

    # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html
    #password: AUTHELIA_SESSION_REDIS_PASSWORD_FILE
    # This is the Redis DB Index https://redis.io/commands/select (sometimes referred to as database number, DB, etc).
    database_index: 0

# Configuration of the authentication regulation mechanism.
#
# This mechanism prevents attackers from brute forcing the first factor.
# It bans the user if too many attempts are done in a short period of
# time.
regulation:
  # The number of failed login attempts before user is banned.
  # Set it to 0 to disable regulation.
  max_retries: 3

  # The time range during which the user can attempt login before being banned.
  # The user is banned if the authentication failed 'max_retries' times in a 'find_time' seconds window.
  # Find Time accepts duration notation. See: https://docs.authelia.com/configuration/index.html#duration-notation-format
  find_time: 2m

  # The length of time before a banned user can login again.
  # Ban Time accepts duration notation. See: https://docs.authelia.com/configuration/index.html#duration-notation-format
  ban_time: 5m

# Configuration of the storage backend used to store data and secrets.
#
# You must use only an available configuration: local, mysql, postgres
storage:
  # The directory where the DB files will be saved
  ## local:
  ##   path: /config/db.sqlite3

  postgres:
    host: postgres
    port: 5432
    database: authelia
    username: authelia
    # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html
    #password: AUTHELIA_STORAGE_POSTGRES_PASSWORD_FILE
    sslmode: disable

# Configuration of the notification system.
#
# Notifications are sent to users when they require a password reset, a u2f
# registration or a TOTP registration.
# Use only an available configuration: filesystem, smtp.
notifier:
  # You can disable the notifier startup check by setting this to true.
  disable_startup_check: false

  # For testing purpose, notifications can be sent in a file
  ## filesystem:
  ##   filename: /config/notification.txt

  # Use a SMTP server for sending notifications. Authelia uses PLAIN or LOGIN method to authenticate.
  # [Security] By default Authelia will:
  #   - force all SMTP connections over TLS including unauthenticated connections
  #      - use the disable_require_tls boolean value to disable this requirement (only works for unauthenticated connections)
  #   - validate the SMTP server x509 certificate during the TLS handshake against the hosts trusted certificates (configure in tls section)
  smtp:
    username: zah@andrewzah.com
    # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html
    #password: AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE
    host: smtp-relay.sendinblue.com
    port: 587
    sender: zah@andrewzah.com
    # HELO/EHLO Identifier. Some SMTP Servers may reject the default of localhost.
    identifier: zah@andrewzah.com
    subject: "[Authelia] {title}"
    startup_check_address: test@authelia.com
    disable_require_tls: false
    disable_html_emails: false
    tls:
      # Server Name for certificate validation (in case you are using the IP or non-FQDN in the host option).
      server_name: smtp.sendinblue.com
      skip_verify: false
      minimum_version: TLS1.2
